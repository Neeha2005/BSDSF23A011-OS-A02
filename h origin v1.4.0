[33mtag v1.4.0[m
Tagger: Zaneeha Afzal <zaneehaafzal@gmail.com>
Date:   Mon Oct 6 19:24:26 2025 +0000

Version 1.4.0: Alphabetical Sort

[33mcommit cca51a7b3a5f4fbb86e64fcc899b5e3e542d75bf[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmain[m[33m, [m[1;33mtag: [m[1;33mv1.4.0[m[33m, [m[1;31morigin/main[m[33m, [m[1;31morigin/HEAD[m[33m, [m[1;32mfeature-alphabetical-sort-v1.4.0[m[33m)[m
Author: Zaneeha Afzal <zaneehaafzal@gmail.com>
Date:   Mon Oct 6 19:23:56 2025 +0000

    Add alphabetical sorting feature for all display modes (v1.4.0)

[1mdiff --git a/Makefile b/Makefile[m
[1mindex a70a0d9..c30a845 100644[m
[1m--- a/Makefile[m
[1m+++ b/Makefile[m
[36m@@ -1,6 +1,6 @@[m
 # ==========================[m
 #  Makefile for Custom LS[m
[31m-#  Versions: v1.1.0, v1.2.0, v1.3.0[m
[32m+[m[32m#  Versions: v1.1.0, v1.2.0, v1.3.0, v1.4.0[m
 # ==========================[m
 [m
 CC = gcc[m
[36m@@ -30,6 +30,12 @@[m [mv1.3.0: $(BIN_DIR)[m
 	$(CC) $(CFLAGS) $(SRC_DIR)/lsv1.3.0.c -o $(BIN_DIR)/lsv1.3.0[m
 	@echo "âœ… Build complete: $(BIN_DIR)/lsv1.3.0"[m
 [m
[32m+[m[32m# Build v1.4.0 (Alphabetical Sort)[m
[32m+[m[32mv1.4.0: $(BIN_DIR)[m
[32m+[m	[32m@echo "ðŸ”¨ Building version v1.4.0 (Alphabetical Sort)..."[m
[32m+[m	[32m$(CC) $(CFLAGS) $(SRC_DIR)/lsv1.4.0.c -o $(BIN_DIR)/lsv1.4.0[m
[32m+[m	[32m@echo "âœ… Build complete: $(BIN_DIR)/lsv1.4.0"[m
[32m+[m
 # Run targets[m
 run-v1.1.0: v1.1.0[m
 	@echo "ðŸš€ Running v1.1.0 (Long Listing)..."[m
[36m@@ -43,23 +49,29 @@[m [mrun-v1.3.0: v1.3.0[m
 	@echo "ðŸš€ Running v1.3.0 (Horizontal Display / -x)..."[m
 	./$(BIN_DIR)/lsv1.3.0 .[m
 [m
[32m+[m[32mrun-v1.4.0: v1.4.0[m
[32m+[m	[32m@echo "ðŸš€ Running v1.4.0 (Alphabetical Sort)..."[m
[32m+[m	[32m./$(BIN_DIR)/lsv1.4.0 .[m
[32m+[m
 # Build all[m
[31m-build-all: v1.1.0 v1.2.0 v1.3.0[m
[32m+[m[32mbuild-all: v1.1.0 v1.2.0 v1.3.0 v1.4.0[m
 	@echo "ðŸŽ¯ All versions built"[m
 [m
 # Clean[m
 clean:[m
 	@echo "ðŸ§¹ Cleaning binaries..."[m
[31m-	rm -f $(BIN_DIR)/lsv1.1.0 $(BIN_DIR)/lsv1.2.0 $(BIN_DIR)/lsv1.3.0[m
[32m+[m	[32mrm -f $(BIN_DIR)/lsv1.1.0 $(BIN_DIR)/lsv1.2.0 $(BIN_DIR)/lsv1.3.0 $(BIN_DIR)/lsv1.4.0[m
 	@echo "âœ… Clean complete."[m
 [m
[32m+[m[32m# Help[m
 help:[m
 	@echo ""[m
 	@echo "Makefile commands:"[m
 	@echo "  make v1.1.0     -> Build v1.1.0 (long listing)"[m
 	@echo "  make v1.2.0     -> Build v1.2.0 (column display)"[m
 	@echo "  make v1.3.0     -> Build v1.3.0 (horizontal display -x)"[m
[31m-	@echo "  make run-v1.3.0 -> Build+run v1.3.0"[m
[32m+[m	[32m@echo "  make v1.4.0     -> Build v1.4.0 (alphabetical sort)"[m
[32m+[m	[32m@echo "  make run-v1.4.0 -> Build+run v1.4.0"[m
 	@echo "  make build-all  -> Build all versions"[m
 	@echo "  make clean      -> Remove binaries"[m
 	@echo ""[m
[1mdiff --git a/src/lsv1.4.0.c b/src/lsv1.4.0.c[m
[1mnew file mode 100644[m
[1mindex 0000000..1e84229[m
[1m--- /dev/null[m
[1m+++ b/src/lsv1.4.0.c[m
[36m@@ -0,0 +1,208 @@[m
[32m+[m[32m#define _XOPEN_SOURCE 700[m
[32m+[m[32m#include <stdio.h>[m
[32m+[m[32m#include <stdlib.h>[m
[32m+[m[32m#include <unistd.h>[m
[32m+[m[32m#include <dirent.h>[m
[32m+[m[32m#include <string.h>[m
[32m+[m[32m#include <errno.h>[m
[32m+[m[32m#include <sys/stat.h>[m
[32m+[m[32m#include <pwd.h>[m
[32m+[m[32m#include <grp.h>[m
[32m+[m[32m#include <time.h>[m
[32m+[m[32m#include <sys/ioctl.h>[m
[32m+[m
[32m+[m[32mextern int errno;[m
[32m+[m
[32m+[m[32m// Display mode flags[m
[32m+[m[32m#define DISPLAY_DEFAULT 0[m
[32m+[m[32m#define DISPLAY_LONG 1[m
[32m+[m[32m#define DISPLAY_HORIZONTAL 2[m
[32m+[m
[32m+[m[32m// Function prototypes[m
[32m+[m[32mint gather_filenames(const char *dir, char ***filenames, int *count, int *maxlen);[m
[32m+[m[32mvoid display_default(char **files, int count, int maxlen);[m
[32m+[m[32mvoid display_horizontal(char **files, int count, int maxlen);[m
[32m+[m[32mvoid display_long(const char *dir);[m
[32m+[m[32mint get_terminal_width();[m
[32m+[m
[32m+[m[32m// ================== New Comparison Function ==================[m
[32m+[m[32mint cmp_str(const void *a, const void *b) {[m
[32m+[m[32m    const char * const *str1 = (const char * const *)a;[m
[32m+[m[32m    const char * const *str2 = (const char * const *)b;[m
[32m+[m[32m    return strcmp(*str1, *str2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// ====================== Main ======================[m
[32m+[m[32mint main(int argc, char *argv[]) {[m
[32m+[m[32m    int opt;[m
[32m+[m[32m    int display_mode = DISPLAY_DEFAULT;[m
[32m+[m
[32m+[m[32m    // Parse options[m
[32m+[m[32m    while ((opt = getopt(argc, argv, "lx")) != -1) {[m
[32m+[m[32m        switch (opt) {[m
[32m+[m[32m        case 'l':[m
[32m+[m[32m            display_mode = DISPLAY_LONG;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 'x':[m
[32m+[m[32m            display_mode = DISPLAY_HORIZONTAL;[m
[32m+[m[32m            break;[m
[32m+[m[32m        default:[m
[32m+[m[32m            fprintf(stderr, "Usage: %s [-l | -x] [directory]\n", argv[0]);[m
[32m+[m[32m            exit(EXIT_FAILURE);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const char *dir = (optind < argc) ? argv[optind] : ".";[m
[32m+[m
[32m+[m[32m    if (display_mode == DISPLAY_LONG) {[m
[32m+[m[32m        display_long(dir);[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    char **files = NULL;[m
[32m+[m[32m    int count = 0, maxlen = 0;[m
[32m+[m[32m    if (gather_filenames(dir, &files, &count, &maxlen) == -1)[m
[32m+[m[32m        return 1;[m
[32m+[m
[32m+[m[32m    // ================= Alphabetical Sorting =================[m
[32m+[m[32m    qsort(files, count, sizeof(char *), cmp_str);[m
[32m+[m
[32m+[m[32m    // Call display functions[m
[32m+[m[32m    if (display_mode == DISPLAY_HORIZONTAL)[m
[32m+[m[32m        display_horizontal(files, count, maxlen);[m
[32m+[m[32m    else[m
[32m+[m[32m        display_default(files, count, maxlen);[m
[32m+[m
[32m+[m[32m    // Free memory[m
[32m+[m[32m    for (int i = 0; i < count; i++) free(files[i]);[m
[32m+[m[32m    free(files);[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// ================= Gather Filenames ==================[m
[32m+[m[32mint gather_filenames(const char *dir, char ***filenames, int *count, int *maxlen) {[m
[32m+[m[32m    DIR *dp = opendir(dir);[m
[32m+[m[32m    if (!dp) {[m
[32m+[m[32m        perror("opendir");[m
[32m+[m[32m        return -1;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    struct dirent *entry;[m
[32m+[m[32m    int size = 0;[m
[32m+[m[32m    char **files = NULL;[m
[32m+[m[32m    *maxlen = 0;[m
[32m+[m[32m    *count = 0;[m
[32m+[m
[32m+[m[32m    while ((entry = readdir(dp)) != NULL) {[m
[32m+[m[32m        if (entry->d_name[0] == '.') continue;[m
[32m+[m[32m        if (*count >= size) {[m
[32m+[m[32m            size = size ? size * 2 : 16;[m
[32m+[m[32m            files = realloc(files, size * sizeof(char *));[m
[32m+[m[32m        }[m
[32m+[m[32m        files[*count] = strdup(entry->d_name);[m
[32m+[m[32m        int len = strlen(entry->d_name);[m
[32m+[m[32m        if (len > *maxlen) *maxlen = len;[m
[32m+[m[32m        (*count)++;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    closedir(dp);[m
[32m+[m[32m    *filenames = files;[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// ================= Default (Down-Then-Across) Display ==================[m
[32m+[m[32mvoid display_default(char **files, int count, int maxlen) {[m
[32m+[m[32m    int width = get_terminal_width();[m
[32m+[m[32m    int spacing = 2;[m
[32m+[m[32m    int cols = width / (maxlen + spacing);[m
[32m+[m[32m    if (cols < 1) cols = 1;[m
[32m+[m[32m    int rows = (count + cols - 1) / cols;[m
[32m+[m
[32m+[m[32m    for (int r = 0; r < rows; r++) {[m
[32m+[m[32m        for (int c = 0; c < cols; c++) {[m
[32m+[m[32m            int i = c * rows + r;[m
[32m+[m[32m            if (i < count)[m
[32m+[m[32m                printf("%-*s", maxlen + spacing, files[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        printf("\n");[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// ================= Horizontal Display (-x) ==================[m
[32m+[m[32mvoid display_horizontal(char **files, int count, int maxlen) {[m
[32m+[m[32m    int width = get_terminal_width();[m
[32m+[m[32m    int spacing = 2;[m
[32m+[m[32m    int col_width = maxlen + spacing;[m
[32m+[m[32m    int curr_width = 0;[m
[32m+[m
[32m+[m[32m    for (int i = 0; i < count; i++) {[m
[32m+[m[32m        if (curr_width + col_width > width) {[m
[32m+[m[32m            printf("\n");[m
[32m+[m[32m            curr_width = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        printf("%-*s", col_width, files[i]);[m
[32m+[m[32m        curr_width += col_width;[m
[32m+[m[32m    }[m
[32m+[m[32m    printf("\n");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// ================= Long Listing (-l) ==================[m
[32m+[m[32mvoid display_long(const char *dir) {[m
[32m+[m[32m    DIR *dp = opendir(dir);[m
[32m+[m[32m    if (!dp) {[m
[32m+[m[32m        perror("opendir");[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    struct dirent *entry;[m
[32m+[m[32m    struct stat st;[m
[32m+[m[32m    char path[1024];[m
[32m+[m
[32m+[m[32m    while ((entry = readdir(dp)) != NULL) {[m
[32m+[m[32m        if (entry->d_name[0] == '.') continue;[m
[32m+[m
[32m+[m[32m        snprintf(path, sizeof(path), "%s/%s", dir, entry->d_name);[m
[32m+[m[32m        if (lstat(path, &st) == -1) continue;[m
[32m+[m
[32m+[m[32m        // File type[m
[32m+[m[32m        printf((S_ISDIR(st.st_mode)) ? "d" :[m
[32m+[m[32m               (S_ISLNK(st.st_mode)) ? "l" :[m
[32m+[m[32m               (S_ISCHR(st.st_mode)) ? "c" :[m
[32m+[m[32m               (S_ISBLK(st.st_mode)) ? "b" :[m
[32m+[m[32m               (S_ISFIFO(st.st_mode)) ? "p" :[m
[32m+[m[32m               (S_ISSOCK(st.st_mode)) ? "s" : "-");[m
[32m+[m
[32m+[m[32m        // Permissions[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IRUSR) ? 'r' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IWUSR) ? 'w' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IXUSR) ? 'x' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IRGRP) ? 'r' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IWGRP) ? 'w' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IXGRP) ? 'x' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IROTH) ? 'r' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IWOTH) ? 'w' : '-');[m
[32m+[m[32m        printf("%c", (st.st_mode & S_IXOTH) ? 'x' : '-');[m
[32m+[m
[32m+[m[32m        // Sticky bit handling[m
[32m+[m[32m        if (st.st_mode & S_ISVTX) printf("t");[m
[32m+[m
[32m+[m[32m        struct passwd *pw = getpwuid(st.st_uid);[m
[32m+[m[32m        struct group *gr = getgrgid(st.st_gid);[m
[32m+[m[32m        printf(" %3ld %-8s %-8s %8ld %.12s %s\n",[m
[32m+[m[32m               st.st_nlink,[m
[32m+[m[32m               pw ? pw->pw_name : "?",[m
[32m+[m[32m               gr ? gr->gr_name : "?",[m
[32m+[m[32m               st.st_size,[m
[32m+[m[32m               ctime(&st.st_mtime) + 4,[m
[32m+[m[32m               entry->d_name);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    closedir(dp);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint get_terminal_width() {[m
[32m+[m[32m    struct winsize w;[m
[32m+[m[32m    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == -1)[m
[32m+[m[32m        return 80; // fallback[m
[32m+[m[32m    return w.ws_col;[m
[32m+[m[32m}[m
